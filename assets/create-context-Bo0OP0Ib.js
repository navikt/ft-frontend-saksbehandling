import{e as f,r as l}from"./index-DASCADcX.js";function x(e){return o=>{e.forEach(t=>{typeof t=="function"?t(o):t!=null&&(t.current=o)})}}function g(...e){return f.useCallback(x(e),e)}var y=function(e,o){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&o.indexOf(r)<0&&(t[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var n=0,r=Object.getOwnPropertySymbols(e);n<r.length;n++)o.indexOf(r[n])<0&&Object.prototype.propertyIsEnumerable.call(e,r[n])&&(t[r[n]]=e[r[n]]);return t};function O(e,o){return`${e} returned \`undefined\`. Seems you forgot to wrap component within ${o}`}function E(e={}){const{name:o,hookName:t="useContext",providerName:r="Provider",errorMessage:n,defaultValue:m}=e,s=l.createContext(m),v=l.forwardRef((u,a)=>{var{children:i}=u,c=y(u,["children"]);const p=f.useMemo(()=>c,Object.values(c));return f.createElement(s.Provider,{value:a?Object.assign(Object.assign({},p),{ref:a}):p},i)});function d(u=!0){var a;const i=l.useContext(s);if(!i&&u){const c=new Error(n??O(t,r));throw c.name="ContextError",(a=Error.captureStackTrace)===null||a===void 0||a.call(Error,c,d),c}return i}return s.displayName=o,[v,d]}export{E as c,x as m,g as u};
